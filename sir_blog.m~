% Fastest network-SIR code in the East
% https://petterhol.me/2018/02/07/fastest-network-sir-code-in-the-east/
%


rng(100)
%% Read network file
AustinSmall10Net10 = readNetFile('pholme_sir/AustinSmall10Net10.csv');

Uni_Nodes = unique([AustinSmall10Net10{:,1}; AustinSmall10Net10{:,2}]);
len_Nodes = length(Uni_Nodes);

% Get neighbor list
neighs = cell(len_Nodes, 1);
for i=1:len_Nodes
    neighs{i} = AustinSmall10Net10{find(AustinSmall10Net10{:,1} == Uni_Nodes(i)),2};
end

%%
% initialize all nodes to susceptible
S = ones(len_Nodes,1);
I = S*0; R = I;

RecT_Max = 1000;
RecT = RecT_Max*S; % Recovery time

% get a random source node i
ini_Node = randi(length(S));
S(ini_Node) = 0;
I(ini_Node) = 1;
R(ini_Node) = 1;

%%
rateSI = 0.5;
rateIR = 0.1;

%%
S_lab = 1; 
I_lab = 2;
R_lab = 3;
Labs = [1:3];
Labs_Str = {'S', 'I', 'R'};
%%
% heap.queue with four cols: Node id, From status, To status, time gap
% heap.nq: number of events in heap.queue.
heap.queue = zeros(1000, 4);
heap.nq = 0;
t = 0;
% insert the infection event of i (at time zero) into the heap
step = t - log(rand)/rateIR;
if rand*rateIR<1
    heap.queue(1,:) = [ini_Node, S_lab, I_lab, step];
    heap.nq = heap.nq+1;
    RecT(ini_Node) = step; 
end

%%
t = 1;
% IT = zeros(100,1);
IT = [];
% while the heap is not empty:
while heap.nq>0
%     if t>length(IT); IT=[IT; zeros(100,1)]; end
    if t>3.7
        1.8
    end
    %% infection
    infectors = find(I==1 & RecT<RecT_Max);
    % for susceptible neighbors j of i:
    for i = 1:length(infectors)
        infector = infectors(i);
        temp_neig = neighs{infector};
        for j = 1:length(temp_neig)
            temp_neig_j = temp_neig(j);
            if S(temp_neig_j)==1
                ini_Node = temp_neig_j;
                
                % if j is not on the heap:
                if length(find(heap.queue(:,1)==ini_Node))==0
                    step = t - log(rand)/rateSI;
                    % if t is earlier than i?s recovery time and j?s current infection time:
                    if  step<=RecT(infector)
                        heap.nq = heap.nq+1;
                        heap.queue(heap.nq,:) = [ini_Node, S_lab, I_lab, step];
                        RecT(ini_Node) = step;
                    end
                end
            end
        end
        
        %%
        if RecT(infector) == RecT_Max
            step = t - log(rand)/rateIR;
            % if t is earlier than i?s recovery time and j?s current infection time:
            if  step<=RecT(infector)
                heap.nq = heap.nq+1;
                heap.queue(heap.nq,:) = [ini_Node, S_lab, I_lab, step];
                RecT(ini_Node) = step;
            end
        end
        
    end
    
   [a, b] = sort(heap.queue(:,end), 'descend')
   heap.queue = heap.queue
    % Update queue at time t
    Event_t = 0;
    if heap.nq>0
%         t = heap.queue(heap.nq, 4);
        t = t+0.1;
        Event_t = t;
        while Event_t<=t && heap.nq>0
            temp = heap.queue(heap.nq, :);
            N_id = temp(1); From = temp(2); ToTo = temp(3); Event_t = temp(4);
            if Event_t<=t;
                eval( [Labs_Str{ismember(Labs, From)}, '(N_id) = 0;'] );
                eval( [Labs_Str{ismember(Labs, ToTo)}, '(N_id) = 1;'] );
            end
            heap.queue(heap.nq, :) = [];
            heap.nq = heap.nq-1;
        end
        
        IT = [IT; t sum(I)];
    end
end

%%
%     if i is infected:
%         mark i as recovered
%         move the last element of the heap to the root
%         heapify-down from the root
%     else: [1]
%         mark i infected
%         add an exponential random number to i?s event time
%         heapify-down from i
%         for susceptible neighbors j of i:
%             get a candidate infection time t (exponentially distributed + current time)
%             if t is earlier than i?s recovery time and j?s current infection time:
%                 if j is not on the heap:
%                     add it to the end of the heap
%                     update the infection time and heapify-up from j [2]
% Comments:
% [1] i has to be susceptible here, it can?t be in the recovered state
% [2] since this update can only make j?s next event time earlier, we can use heapify-up
% heapify-down for cases when a parent-event might be happen later than its children
%%
